R__LOAD_LIBRARY(SampleClasses_h.so)
#include "SampleClasses.h"
#include <string>
#include <vector>

void generateTreeClass(std::string const &name, std::string const &dir = ".", Int_t splitlevel = 0) {
   TFile f((dir + "/" + name + ".root").c_str(), "RECREATE"); // Create file
   TTree tree(name.c_str(), "Tree from a class"); // Create tree

   ClassC *classC = new ClassC(); // One instance to fill the tree

   // Create branch for ClassC
   tree.Branch("ClassC_branch", "ClassC", &classC, 32000, splitlevel);

   // Fill tree
   for (Int_t i = 1; i < 11; ++i) {
      classC->Set(100 + i, 200 + i);
      tree.Fill();
   }

   f.Write(); f.Close(); // Write tree to file
}

// Generate trees
void generateAll() {
   std::string const dir = "./trees";
   generateTreeClass("TreeClass0", dir, 0);
   generateTreeClass("TreeClass2", dir, 2);
}

// Run all tests (assuming that the trees are already generated by
// 'generateAll()' and the selectors are implemented in files
// 'selector.C_filled')
void testClasses() {
   const char *dirSaved = gSystem->pwd(); // Save working directory
   gSystem->cd("./trees"); // Go to trees

   // Loop through test trees
   std::vector<std::string> trees = {"TreeClass0",
                                     "TreeClass2"
                                     };
   for (std::string treeName : trees)
   {
      fprintf(stderr, "Testing tree %s\n", treeName.c_str());
      TFile f((treeName + ".root").c_str());        // Load file
      TTree *t = (TTree*)f.Get(treeName.c_str());   // Load tree
      t->MakeSelector();                            // Generate selector
      t->Process((treeName + "_filled.C").c_str()); // Run (pre-filled) selector
   }
   gSystem->cd(dirSaved); // Restore working directory
}
